# Query type defines the entry points for read operations in GraphQL. Each field in the Query type corresponds to a function (resolver) that will be executed when that field is queried.
type Query {
    jobs: [Job!] # marking job also ass non-nullable, so that the returned array never allows any null value in it.
    job(id: ID!): Job # marking job also ass non-nullable, so that the returned array never allows any null value in it.
    company(id: ID!): Company
}

type Job {
    id: ID! # marking a field as non-nullable with "!" means that this field must always have a value when queried. If a client tries to query this field and it returns null, it will result in an error. So the server must provide ID if client requests it, server can't return null for that
    title: String
    description: String
    #this is how you write a documentation comment. You can use markdown in it, and this comment can be read by developers who want to use your API.
    """
    we could also create our own scalar for Date, but since we want our API to be usable by any client, we may want to avoid that.
    """
    date: String
    company: Company
}

type Company {
    id: ID!
    name: String
    description: String
    #let's add a reverse association now, the company can also have a list of jobs, we will resolve it separately because it doesn't actually exist in the default company schema in the DB.
    # this btw opens up the world of recursive queries,  like you ask for a friend's list of firends, and then for each friend you ask for their list of friends, and so on. GraphQL can handle that just fine, as long as you don't create an infinite loop.
    jobs: [Job!] # marking job also as non-null
}
